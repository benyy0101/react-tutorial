# Sending Requests
리액트 공부를 이어나가다보니, 데이터 요청방법이 헷갈리기 시작합니다. 본지 오래되기도 했구요.
더이상 그냥 어물쩡 넘어가면 안되겠다 싶어서, 다시 복습해보고자 합니다.

이번 챕터에서는 리액트는 어떻게 데이터를 송수신하고 처리하는지 알아보겠습니다.


## 185. Browser-side Apps Don't Directly Talk To Databases

당연한 사실이겠지만, 클라이언트에서 직접적으로 데이터베이스를 연결하는 짓은 미친짓입니다.
기술적으로도 힘들겠지만, 보안상 다른 데이터로의 접근이 무방비하고, 코드 자체도 노출이 되기 때문이죠.
그렇기때문에, 우리는 서버에서 작동하는 백앤드 앱이 필요한겁니다. 리액트는 항상 백앤드 앱과 통신하며 데이터를 주고 받을 겁니다.
이번 챕터에서는 리액트가 어떻게 백앤드와 통신하는지 살펴보겠습니다.

## 186. Sending GET request
리액트전, 우리는 자바스크립트를 이용하고 있다는걸 기억하고 있나요? 퓨어 자바스크립트는 통신 api를 기본적으로 제공하고 있습니다.
우리는 이 api를 이용해서 리액트와 swapi라는 백앤드 앱을 연결해 볼겁니다.

js는 fetch()라는 함수 하나로 수신을 해결하는데, 통신할 주소와(url) 방법(GET,POST, etc)을 매개변수로 갖습니다.
그리고 리턴으로는 Promise를 반환하여, 콜백함수를 붙여 쓸수 있게 만들어 놨습니다.
이렇게 만들어진 이유는 통신이라는것 자체가 비동기적으로 움직이기 때문에 그렇습니다.

따라서 우리는 .then()을 불러와 다른 익명의 함수를 응답이 왔을때 부를수 있게 됩니다.
아니면, .catch()를 사용해 에러 반환을 처리할 수도 있구요.
응답으로 오는 객체인 response는 많은 우리가 원하는 정보뿐만 아니라, 여러 메타데이터도 같이 가지고 있습니다.
어떤 메타 데이터가 있는지는 천천히 살펴보고, 기본적으로 우리가 원하는 데이터는 body안에 담겨있습니다.
그전에 유의할 점이 하나 있습니다. 통신되는 데이터는 자바스크립트 객체 형태로 이동하지 않습니다.
보통은 json,xml,등등으로 변환되어 통신되는데, 그렇기때문에 우리가 받은 json 데이터를 자바스크립트 객체로 전환시켜줘야 편하게 사용할 수 있습니다.
우린 이 작업을 .json()을 사용하여 바꾸어 줄겁니다.
json()을 불러 객체로 만들어주고나면, 우리가 원하는 데이터는 data안에 들어있습니다. 이제 data안에 있는 정보들을 토대로 기능을 만들어도 되고, 기존에 기능과 맞게
새로운 객체로 수정해서 사용하면 되겠습니다.

## 187. Await & Async

다른 종류의 통신으로 넘어가기전, 비동기 함수를 조금더 보고 가겠습니다. 
fetch를 쓰다보면, then()으로 콜백 함수를 호출하기 마련인데, 이게 몇개가 이어지면 가독성이 뚝떨어집니다.
그래서 다른 문법인 await, async 를 주로 많이 활용하죠. 
어떻게 바뀐지는 app.js에 기록해 놓았습니다!

## 188. Waiting for the response...
보통 통신을 하면 생각보다 빠르게 오질 않습니다. 그말은, 유저가 요청을 보내도 같은 화면을 길게는 몇초씩 봐야한다는거고, 이게 지금 잘 돌아가는건지 알 리가 없습니다.
우리는 유저한테 '잘 오고 있습니다', '문제가 있네요', 따위의 진행을 보여줄 필요가 있는것이죠.
이번 챕터에선 state하나를 flag처럼 활용하여 로딩중인지, 아닌지를 나누고, 그에따라 띄우는 컴포넌트를 나루겁니다.

## 189. Handling Errors
에러에는 번호가 존재합니다. 가장 유명한건 404인데, 편의를 위해 그냥 한가지 에러밖에 없다고 가정하겠습니다.
이런 에러를 받았을때에도 우리는 유저에게 '뭔 일이 있어서 데이터를 받지 못했다.'를 꼭 표시해 주어야 합니다.

## 190. Using UseEffect
fetch()라는 함수는 앱 안의 states를 부수적으로 바꿉니다. 이런 동작을 우리는 useEffect안에서 처리한다고 배웠습ㄴ다.
하지만 여기서 handler를 dependancy에 넣어주게되면, 호출할때마다 재생성 되기 때문에, 무한 루프에 빠지게 됩니다.
그걸 막기위해 우리는 handler function을 useCallback으로 감싸 내부 값의 변화가 없을땐, 기존의 있는 함수를 건네 줄 수 있게 합니다.
따라서, useCallback으로 handler가 무한루프를 피하며 useEffect의 dependancy에 들어갈 수 있게 되는 겁니다.

## 191.Before jumping into POST
swapi는 정보를 받을수만 있고, 보낼수는 없습니다. 정확하겐, 보내도 확인할 방법이 없는거죠.
우리는 그래서 firebase라는 툴을 쓸겁니다. 어떻게는 내가 대충 알거에요ㅎㅎ

## 192. POST method













