# React Routing

지금까지의 리액트는 SPA(Single Page Application)으로, 모든 인터렉션이 한페이지 안에서 일어나게 구성이 되어있었다. 하지만, 모두 알다시피, 웹사이트는 한페이지로만 모든 기능을 담을수 없고, 여러 페이지로 구성해 유저가 더 편하게 정보를 찾을수 있게 만들어져있다. 그것을 가능하게 하는 기능을 Routing이라고 부르고(Backend에서 하는 Routing 맞음!) , 지금부터 리액트와 라우팅을 섞어서 만드는 다중 SPA 웹사이트를 구현해보고자한다.

## What is Routing?

웹사이트를 구성할때, 기능들을 각각 다른 웹페이지에 담아서, 명확한 웹사이트를 구현하려 할때 쓰는 방법이다. 예를들어, 어떤 쇼핑몰에는 여러가지 페이지가 있을 수 있는데, 메인, 로그인, 상세품목, 결제창 등등 여러 창들이 존재한다는 걸 떠오르면 이해하기 편하다.

기존의 방식은 페이지마다 다른 url을 만들어서, 서버로부터 다른 html 파일을 받는 것이었다. 하지만, 리액트는 이런 방식을 탈피하고자 나온 방식이고, 당연하게도 이런방식으로 접근하지는 않는다. 리액트에서는 오직 하나의 html을 만들고 보내지만, routing을 통해 url마다 다른 모습의 페이지를 렌더링하여 보내게 되는 것이다.

조금더 요약하자면, 서버사이드 랜더링이 아닌, 클라이언트사이드 랜더링으로 넘어가게 되는것이다.


## 280.Basic
react-router-dom@5 패키지를 통해서 리액트 라우터를 만들수 있다.
기본적으로 url에따라 랜더링 할 컴포넌트를 바꾼다고 보면 된다.
여기서는, /welcome, /product 으로 path를 나누었는데, <Route>에 path를 설정함으로서 라우팅을 해주는 방식이다.
Route 컴포넌트 안에 랜더링하려는 컴포넌트를 넣어주면 된다.
추가로, index.js안에 <App/> 컴포넌트를 <BrowserRouter>로 한번 감싸줘야 한다.

## 281. Link to other url
우리가 기존에 하던 `````<a href="...">````` 같은 방식으로 링크를 걸면 안됩니다. 그렇게 하면, 리액트는 계속 새 웹을 만들어서 보내주는데,
그건 우리가 원하는 클라 사이드 랜더링이 아니죠. 그리고 이렇게 만들면, 기존의 가지고 있는 정보가 다 날라갑니다(따로 캐싱을 하는게 아니라면).
그러니 우린 새로운 웹을 받지 않으면서, state를 다 가진 상태에서 컴포넌트만을 바꾸는 방법이 필요합니다.
아주 고맙게도, react-router에서는 Link라는 컴포넌트를 제고해 주어서, 이런 걱정을 안해도 됩니다!
그냥 ```<a>``` 대신 ```<Link to="url">``` 로 사용하면 되는겁니다.

## 282.Using NavLink
Link 대신 NavLink도 있는데, 여기서 activeClassName을 이용해 지금 active한 페이지에 클래스를 추가 할 수 있다.

## 283. Dynamic Routing using Params
만약 Prduct 페이지에 품목을 게시하고, 클릭하면 상품 내용으로 넘어가는 페이지를 구현하려면 어떻게 해야할까요?
Product에 맞는 페이지를 일일이 구현하는 것은 말이 되지 않습니다. 만든 페이지를 다 Route 컴포넌트로 만들어 넣는것도 안되구요.
이런경우를 위해 react-router는 dynamic routing을 제공합니다. url에 :id 같은 param을 넘겨줌으로서(이건 express와 비슷하네요!) 우리는 필요한 정보를 fetch한 후,
동적으로 페이지를 렌더링 해주면 된는 겁니다.

## 284.Extracting the params from url
당연히 url에 param을 붙혀서 보내면 띠어내는 방법도 있겠죠. useParams는 여러개의 params도 잘 띠어서 변수에 저장시켜 줍니다.
이제 param에따라 데이터를 불러와 랜더링만 해주면 되네요.

## 285. Switching and the use of "exact"
아무래도 url은 트리 구조로 만드는게, 유저 입장에서나 개발자 입장에서나 접근하기 편리합니다.
예를 들어 물품 목록과 상세페이지가 있다면, /product 와 /product-detail이 따로 있는것 보다, product/product-detail/ 처럼 트리구조로 묶여있다면,
보기도 좋고, 구조를 파악하는데도 좋습니다.

그래서 여기서 우리는 product-detail페이지말고, product페이지에 id param을 하나 붙여서 상세페이지를 만들기로 했습니다!
하지만 이런 구성은 치명적인 단점이 있는데요. 바로 매칭되는 모든 경로가 모두 랜더링 된다는 겁니다. 트리구조라고 하면, 극단적으로 한 루트부터 리프 끝까지 랜더링이 될 수도 있는 것이죠.

이럴때 필요한 컴포넌트가 있는데 그게 바로 Switch 컴포넌트 입니다. 이것이 경로를 1대1 매칭 시켜줍니다. 우리가 찾는 경로가 이 컴포넌트안에서 매칭이 된다면, 이 컴포넌트는 탐색을 종료하고 매칭된 컴포넌트만을 랜더합니다.
문제는 이게 또 우리가 원하는 트리구조의 url을 만드는데 방해가 된다는 겁니다.

이를 해결하려면, 더 구체적인 경로가 위에 배치되어있거나(탐색을 위에서부터 시작하니까), 'exact'라는 prop을 달아주면 됩니다.

## 286. Nested Routing
웹페이지를 만들다보면 nesting을 해야 하는 경우가 생깁니다. 그럼 그냥 간단하게 페이지 안에 route 컴포넌트를 추가해서 경로를 만들어주면, 그 페이지에 추가적으로 랜더링이 되게 됩니다!

## 287. Redirecting
유저가 엉뚱한 url을 찍거나, 어떤 행동을 하고 다른 페이지로 자동으로 옮겨가야 할때, Redirect 컴포넌트가 필요하게 됩니다. exact를 꼭 넣어야 무한루프를 방지합니다!

이제 대충 필요한것은 다 찍먹해봤으니, 새로운 프로잭트를 통해서 실습해보겠습니다.


