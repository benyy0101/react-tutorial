# Authentication

이번 챕터에서는 리액트가 클라이언스 상에서 일어나는 로그인, 로그아웃, 그리고 인증 유지를 어떻게 처리하는지 배우게 됩니다.

## 306. What is authentication and Why do we need it

인터넷이 익숙해진 지금, 우리는 로그인의 필요성에 아무 의구심을 가지진 않습니다. 당연히 개인정보를 보호하기 위해 필요하죠.
또한 특정한 정보에대한 접근을 우리는 보호해야 할 때도 있습니다.

이 시점에선 어떻게 인증이 구현되는지 보는게 더 가치있을거 같네요. 우선 리액트 내 인증은 총 2단계를 거칩니다.
1. 권한을 얻어서,
2. 보호되는 데이터로 요청을 보냅니다

예를 들어 우리가 특정 아이디와 비밀번호로 요청을 보냈을때, 
유효한 계정이면 서비스 접근에 대한 권한을, 아니라면 거부 요청을 보냄으로서 인증이 작동하게 됩니다.
이때 서버는 특정한 '토큰'을 주고, 요청마다 이 토큰을 통해 권한이 있는 요청인지 아닌지를 판별하게 됩니다.
하지만 이것만으로는 조금 부족합니다. 당연히 이 토큰이 노출된다면, 상당히 해킹에 취약해 지겠죠.
그렇기 때문에, 단순히 토큰을 주고, 반응을 받는것보다 한번 더 감싸여진 보안이 필요한 것입니다.

보통은 서버에서 클라이언트에대한 고유 id를 만들어, 이 id와 부합한 요청이 왔을때 요청을 허가하는 '세션'을 활용했습니다.
물론 클라이언트도 이 id를 알고 있어야 하는데요, 하지만 이런 방법은 서버와 클라 사이 결합이 느슨한 경우 쉽게 노출이 될 수 있다고 합니다.

그래서 만들어진게 위에서 말한 '토큰' 이라는 개념입니다. 토큰은 그저 어떤 특정한 문자열을 암호화 한 것으로, 이걸 풀 수 있는 키는
서버에만 저장됩니다. 그리고 클라이언트는 오직 생성만 할 수 있고요. 클라이언트가 서버가 원하는 방식의 토큰을 제공하면,
서버는 고유 키로 해독하여 유효성 검증을 진행합니다. 이렇게 서버만 알고있는 무언가로 암호화 및 유효성 검증을 하는 방법을 '토큰'이라고 칭하고 있습니다.

## 308. Settings
별거 없고 이번 챕터에도 firebase를 쓸거고, 거기서 지원하는 auth api 를 활용합니다.

## 309.Sign up page
components/Auth/AuthForm.js 참조.
코드 자체가 간결해서 설명할건 없지만, 조금 풀어써 보자면, 
firebase에 특정 url로 가입할 이메일과 비밀번호를 POST하게 되면, 가입이 진행되고, 또 로그로도 볼 수 있다.

## 310. Providing Feedback to User
components/Auth/AuthForm.js 참조.

## 312. Managing Auth State with Context
우리가 서버에서 토큰을 받아왔다면, 그것을 관리하고 요청에 쓸수 있도록 만들어 주어야 합니다.
이 토큰은 앱 전역에 걸쳐서 사용된기 때문에 단순히 state나 ref로 관리하기에는 어려움이 있습니다.
따라서 우리는 이전에 배운 Redux나 Context을 활용하여 토큰을 컴포넌트들에게 보내줄겁니다.
컨텍스트에 대한 내용이 기억이 잘 안나 복습하고 오겠습니다!

## 313. How to make use of Token
이제 토큰을 잘 저장했은니, 토큰이 필요한 요청을 만들어 보겠습니다. 보통은 데이터베이스에 토큰을 가지고 접근하지만, 아직 그럴싸한 DB가 없으므로,
firebase에서 제공하는 기본적인 비밀번호 바꾸기를 구현해 보겠습니다. 아무나 비밀번호를 바꿀수 있으면 안되니까, 당연히 저의 권한, 즉 토큰이 필요하게 됩니다.

Context를 구현해놨으니 불러오기만 하면 되는 간단한 작업입니다.
components/profile/ProfileForm.js 을 참고하세요

조심할점은, 토큰은 웹페이지마다 처리하는 방법이 다르단 겁니다. 어느곳은 url 쿼리에 담아 달라고 하기도 하고,
다른곳은 header에 담아 보내라고 하기도 하거든요. 그러므로 앱을 만들때, 항상 토큰이 어디에 담겨 가야하는지 먼저 보는게 좋습니다.

## 314. Redirection after logging in

로그인을 하면, 그 페이지에서 나와서 대시보드나 다른 페이지로 이동해야 합니다.
이를 위해선 가장 최근에 배운 라우팅을 사용하면 되는데요. useHistory를 이용해 유저 history를 불러오고, 마지막 페이지를 바꿔주는 방법으로 구현하겠습니다.
크게 어려운 내용은 없고, AuthForm.js에서 54 line을 봐주세요.

## 315. Log out page
로그아웃 기능입니다. 로그아웃은 서버와 통신을 해야하는것처럼 보이지만, 사실 그렇지는 않습니다.
그저 우리가 알고 있는 토큰만 잊어버리면 되기 때문이죠. 서버에도 따로 저장되는 것이 없으니 요청을 보낼 필요도 없습니다.
MainNavigation.js 에서 로그아웃 버튼을 봐주에쇼.

## 316. Protection of pages
라우팅의 약점은, 우리가 url만 맞게 써주면 원하는 페이지로 바로 넘어간다는 점입니다. 예를 들어 우리가 로그인을 하지 않더라도,
/profile로 강제로 넘어가면, 페이지가 뜬다는 것이죠. 물론 거기서 비밀번호 바꾸기를 요청해도, 토큰이 없어서 서버에서는 요청을 거부할겁니다.
하지만 만약 더 중요한 페이지로 우리가 바로 넘어갈수 있다면, 정말 치명적인 버그가 되는 셈입니다.
따라서 우리는 라우팅을 특정한 컨디션 아래에서만 랜더링 하도록 구현해야합니다. 가령 islogin이 true일때만 랜더하게 만드는 것이죠.

말은 거창하지만, 그냥 평소 하던것처럼 조건문을 붙혀서 랜더링하면 됩니다.
App.js에 있습니다.


## 317. Holding the token while refreshing page via storing it in local storage
보통 컨텍스트는 페이지를 리로딩 했을때 초기화 됩니다. 따라서 리로딩을 하면 토큰도 날아가는게 정상이죠.
하지만 그건 우리가 원하는 기능이 절대 아닙니다. 리로딩을 해도, 토큰을 잡고 있어야 할 때가 많으니까요.
보통 크게 두가지 기능이 있는데, 쿠키와 브라우저 로컬 저장소 입니다. 
여기서는 브라우저 로컬에 저장하는 방법을 알아보겠습니다.

localStorage.setItem('token', token); 을 이용해서 로컬 스토리지에 저장하면 됩니다.
주의할 점은, 여기엔 원시적인 데이터 타입만 저장됩니다. 만약 객체를 저장하고 싶다면, json 형태로
변환하여 저장하면 됩니다. 여기선 토큰만을 저장하므로, 문자열로 저장하면 되겠습니다.














